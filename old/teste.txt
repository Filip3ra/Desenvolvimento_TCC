Sequencia: 4 1 3 2 1 4 2 3  | Custo Total: 20.77
Sequencia: 4 1 1 2 4 3 3 2  | Custo Total: 20.77
Sequencia: 4 1 2 2 3 4 3 1  | Custo Total: 20.77
Sequencia: 1 3 2 4 2 3 1 4  | Custo Total: 23.04
Sequencia: 1 3 4 1 2 2 3 4  | Custo Total: 23.04
Sequencia: 2 1 4 2 1 3 3 4  | Custo Total: 26.64
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 26.64
Sequencia: 2 3 1 2 4 3 4 1  | Custo Total: 26.64
Sequencia: 2 2 4 1 4 3 1 3  | Custo Total: 26.64
Sequencia: 3 2 1 1 4 4 3 2  | Custo Total: 26.95
Sequencia: 1 3 2 4 2 3 1 4  | Custo Total: 34.59
Sequencia: 1 3 4 1 2 2 3 4  | Custo Total: 34.59
Sequencia: 1 3 2 4 2 3 1 4  | Custo Total: 36.07
Sequencia: 2 1 4 2 1 3 3 4  | Custo Total: 37.2
Sequencia: 2 1 4 2 1 3 3 4  | Custo Total: 38.52
Sequencia: 1 3 4 1 2 2 3 4  | Custo Total: 39.87
Sequencia: 3 2 1 1 4 4 3 2  | Custo Total: 39.91
Sequencia: 4 1 3 2 1 4 2 3  | Custo Total: 39.97
Sequencia: 4 1 2 2 3 4 3 1  | Custo Total: 39.97
Sequencia: 4 1 1 2 4 3 3 2  | Custo Total: 39.97
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 43.58
Sequencia: 2 3 1 2 4 3 4 1  | Custo Total: 43.58
Sequencia: 3 2 1 1 4 4 3 2  | Custo Total: 43.59
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 44.24
Sequencia: 2 3 1 2 4 3 4 1  | Custo Total: 47.26
Sequencia: 4 1 3 2 1 4 2 3  | Custo Total: 48.44
Sequencia: 4 1 2 2 3 4 3 1  | Custo Total: 49.33
Sequencia: 1 3 2 4 2 3 1 4  | Custo Total: 49.93
Sequencia: 3 2 1 1 4 4 3 2  | Custo Total: 50.59
Sequencia: 4 1 3 2 1 4 2 3  | Custo Total: 52.88
Sequencia: 1 3 4 1 2 2 3 4  | Custo Total: 53.17
Sequencia: 2 1 4 2 1 3 3 4  | Custo Total: 55.16
Sequencia: 2 2 4 1 4 3 1 3  | Custo Total: 55.76
Sequencia: 2 2 4 1 4 3 1 3  | Custo Total: 55.76
Sequencia: 2 3 1 2 4 3 4 1  | Custo Total: 56.1
Sequencia: 1 3 2 4 2 3 1 4  | Custo Total: 56.69
Sequencia: 4 1 3 2 1 4 2 3  | Custo Total: 57.08
Sequencia: 2 1 4 2 1 3 3 4  | Custo Total: 60.06
Sequencia: 2 2 4 1 4 3 1 3  | Custo Total: 60.82
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 64.88
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 65.44
Sequencia: 2 2 4 1 4 3 1 3  | Custo Total: 65.79
Sequencia: 4 1 2 2 3 4 3 1  | Custo Total: 65.97
Sequencia: 4 1 1 2 4 3 3 2  | Custo Total: 66.57
Sequencia: 4 1 1 2 4 3 3 2  | Custo Total: 66.57
Sequencia: 1 3 4 1 2 2 3 4  | Custo Total: 67.23
Sequencia: 1 3 4 1 2 2 3 4  | Custo Total: 67.23
Sequencia: 4 1 1 2 4 3 3 2  | Custo Total: 67.99
Sequencia: 1 3 2 4 2 3 1 4  | Custo Total: 69.43
Sequencia: 4 1 3 2 1 4 2 3  | Custo Total: 71.99
Sequencia: 1 3 2 4 2 3 1 4  | Custo Total: 72.23
Sequencia: 3 2 1 1 4 4 3 2  | Custo Total: 73.03
Sequencia: 4 1 2 2 3 4 3 1  | Custo Total: 76.57
Sequencia: 2 1 4 2 1 3 3 4  | Custo Total: 77.55
Sequencia: 2 3 1 2 4 3 4 1  | Custo Total: 81.84
Sequencia: 3 2 1 1 4 4 3 2  | Custo Total: 87.94
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 89.82
Sequencia: 1 3 4 1 2 2 3 4  | Custo Total: 91.8
Sequencia: 4 1 1 2 4 3 3 2  | Custo Total: 93.43
Sequencia: 2 2 4 1 4 3 1 3  | Custo Total: 93.88
Sequencia: 2 3 1 2 4 3 4 1  | Custo Total: 94.58
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 94.72
Sequencia: 4 1 2 2 3 4 3 1  | Custo Total: 95.03
Sequencia: 4 1 3 2 1 4 2 3  | Custo Total: 97.4
Sequencia: 2 2 4 1 4 3 1 3  | Custo Total: 100.18
Sequencia: 2 1 4 2 1 3 3 4  | Custo Total: 102.12
Sequencia: 1 3 2 4 2 3 1 4  | Custo Total: 105.6
Sequencia: 2 3 1 2 4 3 4 1  | Custo Total: 118.72
Sequencia: 1 3 4 1 2 2 3 4  | Custo Total: 125.17
Sequencia: 2 3 1 2 4 3 4 1  | Custo Total: 126.14
Sequencia: 3 2 1 1 4 4 3 2  | Custo Total: 126.16
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 126.29
Sequencia: 4 1 1 2 4 3 3 2  | Custo Total: 131.65
Sequencia: 2 1 4 2 1 3 3 4  | Custo Total: 135.49
Sequencia: 4 1 2 2 3 4 3 1  | Custo Total: 137.8
Sequencia: 4 1 2 2 3 4 3 1  | Custo Total: 145.22
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 126.29
Sequencia: 4 1 1 2 4 3 3 2  | Custo Total: 131.65
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 126.29
Sequencia: 2 3 4 3 4 1 1 2  | Custo Total: 126.29
Sequencia: 4 1 1 2 4 3 3 2  | Custo Total: 131.65
Sequencia: 2 1 4 2 1 3 3 4  | Custo Total: 135.49
Sequencia: 4 1 2 2 3 4 3 1  | Custo Total: 137.8
Sequencia: 4 1 2 2 3 4 3 1  | Custo Total: 145.22
Sequencia: 4 1 3 2 1 4 2 3  | Custo Total: 152
Sequencia: 2 2 4 1 4 3 1 3  | Custo Total: 154.78
Sequencia: 3 2 1 1 4 4 3 2  | Custo Total: 157.73
Sequencia: 4 1 1 2 4 3 3 2  | Custo Total: 163.22





0 20 44 0.96 0.46 		1 13 75 0.70 0.14 		
0 21 43 0.39 0.60 		1 22 81 0.90 0.15 		
0 19 54 0.77 0.53 		1 8 68 0.86 0.91 		
0 4 35 0.67 0.66 		1 33 81 0.14 0.71 		
1 13 50 0.72 0.74 		0 18 87 0.52 0.77 		
1 14 40 0.26 0.64 		0 11 53 0.44 0.80 		
1 7 28 0.62 0.62 		0 34 70 0.18 0.95 		
0 7 35 0.62 0.32 		1 5 59 0.53 0.53 		
0 9 44 0.70 0.93 		1 12 74 0.97 0.30 		
1 25 57 0.77 0.57 		0 5 71 0.19 0.51 		





/////////////// ESTRATÉGIA 1 //////////////////

Aqui estou acessando o vetor processingOrder pois ele 
guarda um vetor com duas posições v<1,2 ...> que representa 
as duas posições das operações do job, que posso usar para
acessar seus dados em cada vetor, eraliness, tardiness, 
processing time, etc.


  // Criar o vetor de pares <job, operação>
  vector<pair<int, int>> jobOperationPairs(sizeVet);
  vector<int> jobCounters(j.nJobs, 0);
  vector<int> v;
  int indexOp = 0;
  int op1, op2 = 0;
  for (int i = 0; i < sizeVet; i++)
  {
    op1 = j.processingOrder[jobsVet[i] - 1][0];
    op2 = j.processingOrder[jobsVet[i] - 1][1];

    // int currentJob = jobsVet[i] - 1; // índice zero
    cout << "job " << jobsVet[i] << ": " << op1 << ", " << op2
         << " operation: " << j.machine[op1]
         << " processing time: " << j.processingTime[op1]
         << " operation: " << j.machine[op2]
         << " processing time: " << j.processingTime[op2]
         << endl;
  }





/////////// FUNÇÕES DE PRINT //////////////////

      // Exibir randomVet e jobsVet ordenados
      cout << "Vetor randomVet ordenado: [";
      cout << fixed << setprecision(3);
      for (int i = 0; i < sizeVet; i++)
      {
        cout << randomVet[i];
        if (i < sizeVet - 1)
          cout << ", ";
      }
      cout << "]" << endl;

      cout << "Vetor jobsVet ordenado: [";
      for (int i = 0; i < sizeVet; i++)
      {
        cout << jobsVet[i];
        if (i < sizeVet - 1)
          cout << ", ";
      }
      cout << "]" << endl;


        /*
  // Imprimir o vetor de pares <job, operação>
  cout << "Vetor de pares <job, operacao>: ";
  for (const auto &pair : jobOperationPairs)
  {
    cout << "<" << pair.first << "," << pair.second << "> ";
  }
  cout << endl;

  // Imprimir o resultado do agendamento

  cout << "Ordem de randomVet (ordenado): ";
  for (double r : randomVet)
    cout << r << " ";

*/
  cout << "\nOrdem de jobsVet (ordenado): ";
  for (int j : jobsVet)
    cout << j << " ";

  /*
   cout << "\nOrdem de operações agendadas: ";
   for (int op : scheduledOps)
     cout << op << " ";
   cout << endl;
   */




Com base nisso que discutimos dos vetores elite, remaining e mutants, no código abaixo eu preciso realizar um cruzamento entre os dados desses vectors. Ou seja, se tenho as seguintes sequências:

Elite:
Sequencia: 4 1 2 3 3 4 1 2  | Custo Total: 101.66
Sequencia: 1 3 2 4 2 3 1 4  | Custo Total: 105.6
Sequencia: 4 1 2 4 3 3 2 1  | Custo Total: 124.79

Mutants:

Sequencia: 1 3 2 4 2 3 1 4  | Custo Total: 105.6
Sequencia: 3 2 3 1 2 4 1 4  | Custo Total: 143.22
Sequencia: 3 2 4 2 4 1 3 1  | Custo Total: 141.16

Remaining:

Sequencia: 3 4 1 2 1 4 3 2  | Custo Total: 129.29
Sequencia: 4 4 1 3 2 2 3 1  | Custo Total: 139.02
Sequencia: 3 2 4 2 4 1 3 1  | Custo Total: 141.16
Sequencia: 3 2 3 1 2 4 1 4  | Custo Total: 143.22

Preciso juntar mutants com remaining, numa variavel chamada de Aux. Depois vou cruzar sempre um elemento aleatório de Elite com um elemento aleatório de Aux. Preciso realizar N cruzamentos desses, onde N representa a soma do tamanho desses três grupos, elite, remaining e mutants, que nesse exemplo da 3 + 3 + 4, ou seja, realizo 10 cruzamentos. Esses cruzamentos serão os indivíduos da nova população. 

O cruzamento segue as seguintes regras:
Vou gerar uma variável X vazia de mesmo tipo e tamanho do indivíduo em elite, ou seja, se o indivíduo em elite tem 8 posições, então meu X também tem. Ai eu olho pra primeira posição de X e vou decidir se vou copiar o elemento da primeira posição do indivíduo de elite ou de Aux. Faço um sorteio enviesado, de modo que, tenha 70% de chance de selecionar o elemento do indivíduo de elite e os 30% restantes é a chance de puxar de Aux. 

ex:
Elite: 4 1 2 3 3 4 1 2 
Cruzamento com:
vector<pair<vector<int>, double>> Crossover(JIT &j, vector<vector<int>> elite, vector<vector<int>> mutants, vector<vector<int>> remaining)
{
}




Sequencia: 2 3 10 7 4 5 10 1 8 9 8 9 7 3 6 6 4 1 5 2  | Custo Total: 1093.09
Sequencia: 7 2 6 3 5 3 2 6 4 10 8 7 9 5 8 4 1 1 10 9  | Custo Total: 1109.84
Sequencia: 10 9 6 5 4 1 3 1 8 7 3 7 6 2 10 2 4 9 5 8  | Custo Total: 1145.71
Sequencia: 4 8 8 7 10 5 2 9 4 1 5 6 9 10 3 1 2 7 3 6  | Custo Total: 1190.26
Sequencia: 10 2 3 8 5 3 6 6 5 1 1 4 2 8 10 7 4 9 9 7  | Custo Total: 1243.22
Sequencia: 7 7 3 5 5 10 1 2 8 9 9 8 10 4 6 4 3 6 2 1  | Custo Total: 1250.46
Sequencia: 4 4 1 2 9 6 10 8 5 10 9 7 5 2 7 6 8 3 1 3  | Custo Total: 1321.51
Sequencia: 2 3 10 5 4 2 7 8 4 7 3 8 9 6 6 9 1 10 5 1  | Custo Total: 1352.81
Sequencia: 9 2 10 9 6 7 2 5 7 1 4 1 6 10 5 4 3 8 8 3  | Custo Total: 1380.45
Sequencia: 4 8 4 2 6 2 3 1 5 10 6 7 5 8 10 9 7 9 3 1  | Custo Total: 1435.11



// Capturar o tempo inicial
      auto start = chrono::high_resolution_clock::now();
     
     
     
      // Capturar o tempo final
      auto end = chrono::high_resolution_clock::now();

      // Calcular a duração em milissegundos
      chrono::duration<double, milli> duration = end - start;





Dado que você analisou os arquivos do meu algoritmo nessa conversa, olhe para a função Fitness no arquivo brkga.cpp. Nela estou calculando o fitness de modo que ele olha pra uma operação, seu tempo de processamento, suas penalidades, depois olha para a próxima operação, e dado que processou uma anteriormente ele vai somando os tempos de processamento, tempo de processamento atual, etc. Ou seja, ele basicamente olha as operações linearmente e vai calculando sua posição de processamento com base nas operações anteriormente processadas, ele não otimiza a posição da operação para minimizar as penalidades. 

Por exemplo:
Se ele recebe uma instância com 4 jobs e duas máquinas, então cada job tem duas operações. Suponha que a ordem das operações seja:
[job3 op1 m1][job4 op1 m1][job1 op1 m1][job2 op1 m2][job3 op2 m2][job1 op2 m2][job4 op2 m22][job2 op2 m1]

E seus respectivos tempos de processamento sejam:
5, 5, 10, 5, 5, 5, 5, 5.

isso significa que no código atual, o tempo total dessa instância seria 45, pois ele simplesmente coloca a operação para processar logo após o tempo de término da operação anterior. E por exemplo, a operação 1 do job 2 que é processada na máquina 2 ela só iria começar a processar no instante 20, pois anteriormente teve outras operações processadas. Mas perceba que ela não precisa esperar até o instante 20 para começar a processar, pois ela é a primeira operação a ser processada na máquina 2, e também é a primeira operação do job 2 a ser processada, logo, ela não tem conflito com outras operações, portanto ela poderia começar no instante 0 da máquina 2 sem problemas. 

A solução que quero implementar aqui é o que chamam de "left shift" e também "right shift", ou seja